#+TITLE:  Emacs Configuration File
#+AUTHOR: Trevor Bekolay
$+EMAIL:  tbekolay@gmail.com

* Introduction

This is my =.emacs= file, written using [[http://www.orgmode.org][org-mode]], so that I can
organize it and take notes on all the complexity.

It's inspired by several sources; I'll try to keep this list updated
as I crib pieces from various sources.

| Source                 | Stolen                                               |
|------------------------+------------------------------------------------------|
| [[https://github.com/howardabrams/dot-files][howardabrams/dot-files]] | A lot! This was the original inspiration.            |
| [[https://github.com/larstvei/dot-emacs][larstvei/dot-emacs]]     | The =tangle-init= function, and some other snippets. |
| [[https://github.com/joedicastro/dotfiles][joedicastro/dotfiles]]   | No backups! Makes sense! Also a few snippets.        |
| [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua's config]]    | A few snippets.                                      |


If you are playing around with the =org-mode= version, note:

- The =tab= key opens/close a particular section
- Shift + =tab= cycles between the outline and full text
- Render it with:  =C-c C-v t=
- Creates a file:  =~/.emacs-ext.el=

** Emacs Executable

This file is really a /script/ that requires version 24 of Emacs.
I install Emacs using [[http://brew.sh/][Homebrew]] or [[https://packages.debian.org/sid/emacs][apt-get]], depending
on what operating system I'm on.

*** Mac OS X

#+BEGIN_EXAMPLE
  brew install emacs --cocoa --srgb --with-gnutls
  ln -s /usr/local/Cellar/emacs/24.4/Emacs.app /Applications/Emacs.app
#+END_EXAMPLE

I manually link =Emacs.app= rather than using =brew linkapps=
because I don't like having all the Python "apps" like Idle
linked to =/Applications=.

*** Debian

Debian unstable (sid) has =emacs24= as its default now, so
installation is as simple as

#+BEGIN_EXAMPLE
  sudo apt-get install emacs
#+END_EXAMPLE

* Frontmatter

All =elisp= scripts start with some standard frontmatter.
I'll do the same, though this isn't designed to be used by others.

#+BEGIN_SRC elisp :comments off :padline no
  ;;; init.el --- Trevor Bekolay's emacs configuration.
  ;;
  ;; Copyright (c) 2014 Trevor Bekolay
  ;;
  ;; Author: Trevor Bekolay <tbekolay@gmail.com>
  ;; URL: https://github.com/tbekolay/dotfiles
  ;; Version: 0.1.0

  ;; This file is not part of GNU Emacs.

  ;;; Commentary:

  ;; This file sets up Emacs like Trevor likes it.
  ;;
  ;; ---------------------------------------------
  ;; WARNING! This file is automatically generated
  ;; from its source, which lives in =emacs.org=
  ;; in a clone of tbekolay/dotfiles.
  ;; Do not edit the generated file directly!
  ;; Any changes will be overridden when the
  ;; source is modified!
  ;; ---------------------------------------------

  ;;; License:

  ;; Copyright (c) 2014-2015 Trevor Bekolay
  ;;
  ;; Permission is hereby granted, free of charge, to any person
  ;; obtaining a copy of this software and associated documentation
  ;; files (the "Software"), to deal in the Software without
  ;; restriction, including without limitation the rights to use, copy,
  ;; modify, merge, publish, distribute, sublicense, and/or sell copies
  ;; of the Software, and to permit persons to whom the Software is
  ;; furnished to do so, subject to the following conditions:
  ;;
  ;; The above copyright notice and this permission notice shall be
  ;; included in all copies or substantial portions of the Software.
  ;;
  ;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  ;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  ;; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  ;; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  ;; BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ;; ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  ;; CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  ;; SOFTWARE.

  ;;; Code:
#+END_SRC

* General Settings

** Directory Structure

We'll load a few directories into variables for convenience.

#+BEGIN_SRC elisp
  (defvar dotfiles-dir (file-name-directory load-file-name)
    "The directory of the dotfiles repository.")
#+END_SRC

In case this is the first time running this on a computer, we need
to make sure the following directories have been created.

#+BEGIN_SRC elisp
  (let* ((subdirs '("elisp" "backups" "snippets" "ac-dict"))
         (fulldirs (mapcar (lambda (d) (concat user-emacs-directory d)) subdirs)))
    (dolist (dir fulldirs)
      (when (not (file-exists-p dir))
        (message "Make directory: %s" dir)
        (make-directory dir))))
#+END_SRC

** Setting up the Load Path

Extra packages not available via the package manager go in
=~/.emacs.d/elisp=

#+BEGIN_SRC elisp
  (add-to-list 'load-path (concat user-emacs-directory "elisp"))
#+END_SRC

Load up common lisp. I can't say I know exactly what this gives us,
but it is likely needed by some of the snippets I've copied.

#+BEGIN_SRC elisp
  (eval-when-compile
    (require 'cl))
#+END_SRC

** Autotangle

Normally we start by running =bootstrap.el=, which will tangle
this file to =~/.emacs.d/init.el=. However, when working on this file,
it's convenient to not have to run that after every change.
This will tangle and byte-compile whenever we save this file.

#+BEGIN_SRC elisp
  (defun tb-tangle-init ()
    "If the current buffer is 'emacs.org' the code-blocks are tangled, and the tangled file is compiled."
    (when (equal (buffer-file-name)
                 (expand-file-name "~/Code/dotfiles/emacs.org"))
      ;; Avoid running hooks when tangling.
      (let ((prog-mode-hook nil))
        (org-babel-tangle)
        (byte-compile-file (concat user-emacs-directory "init.el")))))

  (add-hook 'after-save-hook 'tb-tangle-init)
#+END_SRC

* Package Initialization
** Package Manager

Emacs has become like every other operating system, and now has a
[[http://tromey.com/elpa/][package manager]] with its own collection repository, but since it is
so conservative, we need to add more repositories.

#+BEGIN_SRC elisp
  (require 'package)
  (setq package-enable-at-startup nil)
  (package-initialize)
  (setq package-archives '(("org"       . "http://orgmode.org/elpa/")
                           ("melpa"     . "http://melpa.org/packages/")
                           ("gnu"       . "http://elpa.gnu.org/packages/")
                           ("marmalade" . "http://marmalade-repo.org/packages/")))
#+END_SRC

The rest of this file becomes a whole lot simpler with the =use-package=
package, so we'll ensure that's installed first.

#+BEGIN_SRC elisp
  (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package))
  (eval-when-compile
    (require 'use-package))
  (require 'diminish)
  (require 'bind-key)
  (setq use-package-always-ensure t)
#+END_SRC

We'll start by updating any already installed packages.
On the first run of this, nothing should happen,
so we're safe.

#+BEGIN_SRC elisp
  (use-package epl
      :commands epl-upgrade)
  (epl-upgrade)
#+END_SRC

** Installing Extra Packages

Here are the packages from Howard Abrams. Leaving them here so that
I can review them eventually.

#+BEGIN_EXAMPLE
  (packages-install
                 '(auto-complete
                   ack-and-a-half
                   dired-details
                   color-identifiers-mode  ;; Color variables differently
                   epl
                   env-var-import
                   esh-buf-stack
                   expand-region
                   flx
                   flx-ido
                   flycheck
                   flycheck-color-mode-line
                   git-blame
                   git-commit-mode
                   git-gutter-fringe
                   gitconfig-mode
                   gitignore-mode
                   graphviz-dot-mode
                   hungry-delete
                   ido-vertical-mode
                   iy-go-to-char
                   linum-relative
                   magit
                   markdown-mode
                   multiple-cursors
                   paredit
                   redo+             ;; If not installed, edit mac-key-mode
                   smex
                   thesaurus
                   undo-tree
                   visual-regexp
                   yasnippet))
#+END_EXAMPLE

And here are the packages that I used in prelude.

#+BEGIN_EXAMPLE
(defvar prelude-packages
  '(ack-and-a-half
    anzu
    browse-kill-ring
    dash
    discover-my-major
    diff-hl
    diminish
    easy-kill
    epl
    expand-region
    flycheck
    git-timemachine
    gitconfig-mode
    gitignore-mode
    grizzl
    magit
    move-text
    ov
    smartparens
    rainbow-mode
    undo-tree
    volatile-highlights)
  "A list of packages to ensure are installed at launch.")
#+END_EXAMPLE

And even more packages to look into, or learn better

- =dired-x=
- =ediff=
  - Consider =(setq ediff-window-setup-function 'ediff-setup-windows-plain)=
- =midnight= (especially if I start doing =emacsclient=)
- =abbrev=
- =winner-mode=

* Variables

General settings about me that other packages can use.

#+BEGIN_SRC elisp
  (setq user-full-name "Trevor Bekolay"
        user-mail-address "tbekolay@gmail.com")
#+END_SRC

** Whitespace

I have learned to distrust tabs in my source code, so let's make
sure that we only have spaces. See [[http://ergoemacs.org/emacs/emacs_tabs_space_indentation_setup.html][this discussion]] for details.

#+BEGIN_SRC elisp
  (setq-default indent-tabs-mode nil)
  (setq tab-width 4)
#+END_SRC

Make tab key do indent first then completion.

#+BEGIN_SRC elisp
  (setq-default tab-always-indent 'complete)
#+END_SRC

I'm kind of undecided about this... but it is, I believe,
Good Unix to put newlines at the end of all files.

#+BEGIN_SRC elisp
  (setq require-final-newline t)
#+END_SRC

** File Sizes

By default, =emacs= garbage collects after 0.76 MB of accumulated data.
That's too frequent! Let's go with every 50 MB.

#+BEGIN_SRC elisp
  (setq gc-cons-threshold 50000000)
#+END_SRC

Warn when opening files bigger than 100 MB.

#+BEGIN_SRC elisp
  (setq large-file-warning-threshold 100000000)
#+END_SRC

** Aggressive Auto Indention

Automatically indent without use of the tab found in [[http://endlessparentheses.com/permanent-auto-indentation.html][this article]],
and seems to be quite helpful for many programming languages.

#+BEGIN_SRC elisp
  (use-package aggressive-indent
      :init (add-hook 'emacs-lisp-mode-hook #'aggressive-indent-mode)
            (add-hook 'css-mode-hook #'aggressive-indent-mode))
#+END_SRC

* User Interface (UI)
** General

I've been using Emacs for many years, and appreciate a certain
minimalist approach to its display. While you can turn these off
with the menu items now, it is just as easy to set them here.

#+BEGIN_SRC elisp
  ;; Less verbose scratch buffer intro
  (setq initial-scratch-message ";; Scratch buffer\n\n")

  ;; Better than audio bell ...
  (setq visible-bell t)

  ;; Don't need that startup screen!
  (setq inhibit-startup-screen t)

  ;; Blinking cursor is truly the worst
  (blink-cursor-mode -1)

  ;; Highlight the current line
  (global-hl-line-mode +1)

  ;; Nice scrolling
  (setq scroll-margin 10
        scroll-conservatively 100000
        scroll-preserve-screen-position 1)

  ;; No menus... but only in text mode
  (unless (window-system)
    (menu-bar-mode 0))

  ;; Toolbars are not necessary
  (when (window-system)
    (tool-bar-mode 0)
    (when (fboundp 'horizontal-scroll-bar-mode)
      (horizontal-scroll-bar-mode -1)))

  ;; Enable y/n answers
  (fset 'yes-or-no-p 'y-or-n-p)

  ;; More useful frame title. If it's a file, show the filename;
  ;; if not visiting a file, then buffer name
  (setq frame-title-format
        '(:eval (if (buffer-file-name)
                    (abbreviate-file-name (buffer-file-name))
                 "%b")))

  ;; Highlight various actions
  (use-package volatile-highlights
      :config (volatile-highlights-mode t))

  ;; Trying show-paren-mode; could be good
  (show-paren-mode 1)

  ;; More miscellaneous good settings
  (setq save-interprogram-paste-before-kill t
        mouse-yank-at-point t)
#+END_SRC

** Windowing

I mostly use Emacs in a GUI, with multiple windows.

There are two nice packages for dealing with changing window / frame focus
with the keyboard. We'll use them, and have them play nice together.

TODO these aren't working right now. Keybinding issues with orgmode I think.

#+BEGIN_SRC elisp
  (use-package windmove
      :disabled t
      :init (windmove-default-keybindings))

  (use-package framemove
      :disabled t
      :init (setq framemove-hook-into-windmove t)
      :config (windmove-default-keybindings))
#+END_SRC

Here's a helper function. Will I use it a lot? TBD!

#+BEGIN_SRC elisp
  (defun tb-swap-windows ()
    "If you have 2 windows, it swaps them."
    (interactive)
    (if (/= (count-windows) 2)
        (message "You need exactly 2 windows to do this.")
      (let* ((w1 (car (window-list)))
             (w2 (cadr (window-list)))
             (b1 (window-buffer w1))
             (b2 (window-buffer w2))
             (s1 (window-start w1))
             (s2 (window-start w2)))
        (set-window-buffer w1 b2)
        (set-window-buffer w2 b1)
        (set-window-start w1 s2)
        (set-window-start w2 s1)))
    (other-window 1))
#+END_SRC

** Mac OS X

This section contains Mac OS X specific settings.
Most of these are only enabled in the GUI, not the terminal.

First, the Mac OS X gui loads up with the default system
=$PATH=, which is inadequate. Fortunately the =exec-path-from-shell=
package fixes this.

#+BEGIN_SRC elisp
  (use-package exec-path-from-shell
      :if (and (eq system-type 'darwin) window-system)
      :config (exec-path-from-shell-initialize))
#+END_SRC

Next, if I ever want to use =proced-mode=, we have to do
this with =vkill= on Mac OS X.
I won't do this for now, but I'm keeping it in here just in case.

#+BEGIN_SRC elisp :tangle no
  (use-package vkill
      :if (eq system-type 'darwin)
      :commands (vkill list-unix-processes)
      :bind ("C-x p" . vkill))
#+END_SRC

I don't use this, but in case I want to use the "fn" (function)
key for something, I could do it here.

#+BEGIN_SRC elisp :tangle no
  (when (eq system-type 'darwin)
      (setq ns-function-modifier 'hyper))
#+END_SRC

Now here's an important one: swapping meta (alt/option)
and super (command). I need this real bad, as I'm really used
to using the command key for =M-= commands.

#+BEGIN_SRC elisp
  (defvar mac-command-modifier)  ;; suppress free variable warning on Linux
  (defvar mac-option-modifier)  ;; suppress free variable warning on Linux
  (when (eq system-type 'darwin)
    (defun tb-swap-meta-and-super ()
      "Swap the mapping of Meta and Super."
      (interactive)
      (if (eq mac-command-modifier 'super)
          (progn
            (setq mac-command-modifier 'meta)
            (setq mac-option-modifier 'super)
            (message "Command is now bound to META and Option is bound to SUPER."))
        (progn
          (setq mac-command-modifier 'super)
          (setq mac-option-modifier 'meta)
          (message "Command is now bound to SUPER and Option is bound to META.")))))
  ;; I want to do this by default!
  (when (fboundp 'tb-swap-meta-and-super) (tb-swap-meta-and-super))
#+END_SRC

** Debian
Using XFCE, Emacs opens Iceweasel even though I prefer Chrome.
This makes it use the =exo-open= command,
which uses the configured preferred browser.

#+BEGIN_SRC elisp
  (when (eq system-type 'gnu/linux)
    (setq browse-url-browser-function 'browse-url-generic
          browse-url-generic-program "exo-open"))
#+END_SRC

** Mode Line

I'm still not completely sure how I want to configure the modeline,
so for the time being I'll defer most of the choices to the
=smart-mode-line= package. I will endeavour to care more!

#+BEGIN_SRC elisp
  (column-number-mode t)

  (use-package smart-mode-line
      :init (setq sml/no-confirm-load-theme t)
      :config
      (sml/setup)
      (sml/apply-theme 'automatic)
      (add-to-list 'sml/replacer-regexp-list '("^~/Code/nengo/" ":Nengo:"))
      (add-to-list 'sml/replacer-regexp-list '("^~/Dropbox/" ":DB:"))
      (add-to-list 'sml/replacer-regexp-list '("^~/Code/" ":C:")))
#+END_SRC

So here's where I should use =diminish=, or =smart-mode-line='s
own version, =rich-minority=. I don't know yet though! TODO!

#+BEGIN_SRC elisp :tangle no
  (use-package diminish)
  (use-pacakge rich-minority
      :config (rich-minority-mode 1))
#+END_SRC

I have decided that I'm a fan of the =anzu= package for highlighting
the number of matches when doing searches.

#+BEGIN_SRC elisp
  (use-package anzu
      :config (global-anzu-mode +1))
#+END_SRC

** Fringe

Highlight differences between current and committed files in the fringe.

#+BEGIN_SRC elisp
  (use-package diff-hl
      :config (global-diff-hl-mode +1)
              (add-hook 'dired-mode-hook 'diff-hl-dired-mode))
#+END_SRC

* Key Bindings
** Searching

It's more likely useful to have regex searches
than non-regex searches, so let's switch things around.

#+BEGIN_SRC elisp
  (global-set-key (kbd "C-s") 'isearch-forward-regexp)
  (global-set-key (kbd "C-r") 'isearch-backward-regexp)
  (global-set-key (kbd "C-M-s") 'isearch-forward)
  (global-set-key (kbd "C-M-r") 'isearch-backward)
#+END_SRC

* Loading and Finding Files
** Autorevert

There are almost no cases in which I want to be editing a stale buffer.

#+BEGIN_SRC elisp
  (global-auto-revert-mode t)
#+END_SRC

** Autosave

With version 24.4 of Emacs, we can save all files when Emacs
loses frame focus.

#+BEGIN_SRC elisp
  (add-hook 'focus-out-hook (lambda () (save-some-buffers t)))
#+END_SRC

** Helper functions

These helper functions are rather helpful.

#+BEGIN_SRC elisp
  (defun tb-rename-buffer-and-file ()
    "Rename current buffer and if the buffer is visiting a file, rename it too."
    (interactive)
    (let ((filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (rename-buffer (read-from-minibuffer "New name: " (buffer-name)))
        (let ((new-name (read-file-name "New name: " filename)))
          (cond
           ((vc-backend filename) (vc-rename-file filename new-name))
           (t
            (rename-file filename new-name t)
            (set-visited-file-name new-name t t)))))))

  (defun tb-delete-file-and-buffer ()
    "Kill the current buffer and deletes the file it is visiting."
    (interactive)
    (let ((filename (buffer-file-name)))
      (when filename
        (if (vc-backend filename)
            (vc-delete-file filename)
          (when (y-or-n-p (format "Are you sure you want to delete %s? " filename))
            (delete-file filename)
            (message "Deleted file %s" filename)
            (kill-buffer))))))
#+END_SRC

** Dired options

If I'm copying or deleting, chances are I want it to be recursive.

#+BEGIN_SRC elisp
  (setq dired-recursive-deletes 'always)
  (setq dired-recursive-copies 'always)
#+END_SRC

This enhancement to dired hides the ugly details until you hit '('
and shows the details with ')'. I also change the [...] to an asterisk.

#+BEGIN_SRC elisp
  (use-package dired-details
      :init (setq dired-details-hidden-string "* ")
      :config (dired-details-install))
#+END_SRC

** Ibuffer

Makes the buffer list, =C-x C-b=, more like =dired=.

#+BEGIN_SRC elisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC

** Ido

After using Helm for a week or so, I still prefer the feel of Ido.
So let's use it everywhere!

#+BEGIN_SRC elisp
  (use-package ido
      :config (ido-mode 1))

  (use-package ido-ubiquitous
      :init (setq ido-everywhere 1))
#+END_SRC

Use [[https://github.com/lewang/flx][flex matching]].

#+BEGIN_SRC elisp
  (use-package flx-ido
      :init (setq ido-enable-flex-matching t)
      :config (flx-ido-mode 1))
#+END_SRC

The possible completions are much easier to read vertically.
For this, I use [[https://github.com/gempesaw/ido-vertical-mode.el][ido-vertically]].

#+BEGIN_SRC elisp
  (use-package ido-vertical-mode
      :init (setq ido-vertical-define-keys 'C-n-C-p-up-and-down)
      :config (ido-vertical-mode 1))
#+END_SRC

** Smex

Better =M-x= behavior, using Ido.

#+BEGIN_SRC elisp
  (use-package smex
      :bind (("M-x" . smex)
             ("M-z" . smex)  ;; Zap to char sucks
             ("M-X" . smex-major-mode-commands)
             ("C-c C-c M-x" . execute-extended-command)))
#+END_SRC

** Backup Settings

Yeah, we could move all backup files to some directory,
but in N years of using Emacs, I've never once looked in this
directory for some magical lost text. Fuck backups! Git for life!

#+BEGIN_SRC elisp
  (setq make-backup-files nil)
  (setq auto-save-default nil)
  (setq auto-save-list-file-prefix nil)
#+END_SRC

** Save Place

The [[http://www.emacswiki.org/emacs/SavePlace][Save Place]] mode will remember your location in a file.

#+BEGIN_SRC elisp
  (use-package saveplace
      :init (setq-default save-place t))
#+END_SRC

** Save History

Saves a few more things.

#+BEGIN_SRC elisp
  (use-package savehist
      :init (setq savehist-additional-variables
              '(search-ring regexp-search-ring)  ;; search entries
              savehist-autosave-interval 60  ;; save every minute
              savehist-file (concat user-emacs-directory "savehist"))  ;; keep the home clean
      :config (savehist-mode +1))
#+END_SRC

* Completion

** Spell Checking

I like spell checking with [[http://www.emacswiki.org/emacs/FlySpell][FlySpell]], but we use =aspell=
instead of the default =ispell=.

#+BEGIN_SRC elisp
  (use-package flyspell
      :init
      (setq-default ispell-program-name "hunspell")
      (setq ispell-really-hunspell t)
      (setq flyspell-issue-message-flag nil)
      (add-hook 'text-mode-hook (lambda () (flyspell-mode 1)))
      (add-hook 'python-mode-hook (flyspell-prog-mode)))
#+END_SRC

* Miscellaneous Settings

** Whitespace

When I save, I want to always, and I do mean always strip all
trailing whitespace from the file.

#+BEGIN_SRC elisp
  (add-hook 'before-save-hook 'whitespace-cleanup)
#+END_SRC

I like to see bad whitespace. But not all whitespace.

#+BEGIN_SRC elisp
  (use-package whitespace
      :init
      (setq whitespace-line-column 80
            whitespace-style '(face tabs empty trailing lines-tail))
      (add-hook 'text-mode-hook (whitespace-mode +1))
      (add-hook 'org-mode-hook (whitespace-mode +1)))
#+END_SRC

Here's a nice helper function to reindent the whole buffer.

#+BEGIN_SRC elisp :tangle no
  FIXME!
  (defun tb-indent-buffer ()
    "Indent the whole buffer."
    (interactive)
    (mark-whole-buffer)
    (indent-region))
#+END_SRC

** Expand-region

This seems pretty useful. I should try to muscle-memory it.

#+BEGIN_SRC elisp
  (use-package expand-region
      :bind (("C-=" . er/expand-region)
             ("C-+" . er/contract-region)))
#+END_SRC

** Auto-indent yanked text

When programming, it's rare that we want to keep the indentation
on yanked text. This auto-indents it instead.

#+BEGIN_SRC elisp
  ;; Max number of characters to indent
  (defvar yank-indent-threshold 1000)

  ;; Programming-modes with indentation senstivity should be listed here
  (defvar indent-sensitive-modes
      '(conf-mode coffee-mode haml-mode python-mode slim-mode yaml-mode))

  ;; Only non-programming modes need to be listed here
  (defvar yank-indent-modes '(LaTeX-mode TeX-mode))

  (defun yank-advised-indent-function (beg end)
    "Do indentation, as long as the region isn't too large."
    (if (<= (- end beg) yank-indent-threshold)
        (indent-region beg end nil)))

  ;; Make it possible to advise multiple functions
  (defmacro advise-commands (advice-name commands class &rest body)
    "Apply advice named ADVICE-NAME to multiple COMMANDS.

  The body of the advice is in BODY."
    `(progn
       ,@(mapcar (lambda (command)
                   `(defadvice ,command (,class ,(intern (concat (symbol-name command) "-" advice-name)) activate)
                      ,@body))
                 commands)))

  (advise-commands "indent" (yank yank-pop) after
    "If current mode is one of `yank-indent-modes',
  indent yanked text (with prefix arg don't indent)."
    (if (and (not (ad-get-arg 0))
             (not (member major-mode indent-sensitive-modes))
             (or (derived-mode-p 'prog-mode)
                 (member major-mode yank-indent-modes)))
        (let ((transient-mark-mode nil))
          (yank-advised-indent-function (region-beginning) (region-end)))))
#+END_SRC

** Regular expressions

Better regex syntax, apparently!

#+BEGIN_SRC elisp
  (use-package re-builder
      :init (setq reb-re-syntax 'string))
#+END_SRC

** Compilation

Some improvements to compilation. I don't use this yet,
but perhaps someday I will.

#+BEGIN_SRC elisp
  (defun tb-colorize-compilation-buffer ()
    "Colorize a compilation mode buffer."
    (interactive)
    ;; We don't want to mess with child modes such as grep-mode, ack, ag, etc
    (when (eq major-mode 'compilation-mode)
      (let ((inhibit-read-only t))
        (ansi-color-apply-on-region (point-min) (point-max)))))

  (use-package compile
      :init (setq compilation-ask-about-save nil  ; Just save before compiling
                  compilation-always-kill t       ; Just kill old compile processes
                                                  ; before starting the new one
                  compilation-scroll-output 'first-error))

  ;; Colorize output of Compilation Mode
  (use-package ansi-color
      :init
      (add-hook 'compilation-filter-hook #'tb-colorize-compilation-buffer))
#+END_SRC

** Unfill paragraph

Emacs has =fill-paragraph= to add newlines in the right spaces,
but I often find myself in the opposite situation, needing to
make a paragraph be a single line. Yeah, this is mostly for filling
in shitty webforms.

#+BEGIN_SRC elisp
  (defun unfill-paragraph ()
    "Take a multi-line paragraph and make it into a single line of text."
    (interactive)
    (let ((fill-column (point-max)))
      (fill-paragraph nil)))

  (global-set-key (kbd "C-q") 'unfill-paragraph)
#+END_SRC

** Undo-tree

Unequivocably a better way to do undo.

#+BEGIN_SRC elisp
  (use-package undo-tree
      :config (global-undo-tree-mode))
#+END_SRC

** Uniquify

Get rid of silly <1> and <2> to buffers with the same file name,
using [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Uniquify.html][uniquify]].

#+BEGIN_SRC elisp
  (use-package uniquify
      :ensure f
      :init
      (setq uniquify-buffer-name-style 'forward)
      (setq uniquify-separator "/")
      (setq uniquify-after-kill-buffer-p t)
      ;; don't muck with special buffers
      (setq uniquify-ignore-buffers-re "^\\*"))
#+END_SRC

** Flycheck

[[https://github.com/flycheck/flycheck][Flycheck]] seems to be quite superior to Flymake.

#+BEGIN_SRC elisp
  (use-package flycheck
      :init (add-hook 'after-init-hook #'global-flycheck-mode))
#+END_SRC

** IRC

ERC seems useful!

#+BEGIN_SRC elisp
  (use-package erc
      :commands erc)
#+END_SRC

* Git
** Magit

I need to learn this better, but now now, we'll start with
install =magit= so that we can have nice interactive rebase buffers.

#+BEGIN_SRC elisp
  (use-package magit
      :init (setq magit-last-seen-setup-instructions "1.4.0"))
#+END_SRC

* Org-Mode

See [[file:emacs-org.org][emacs-org-mode.el]] for details on my [[http://www.orgmode][Org-Mode]] settings.

#+BEGIN_SRC elisp :tangle no
  (require 'init-org-mode)
#+END_SRC

#+BEGIN_SRC elisp
  (use-package org-bullets
      :init (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC

* LaTeX
Make AUCTex aware of style files and multi-file documents.

#+BEGIN_SRC elisp
  (use-package auctex
      :init (setq TeX-auto-save t)
            (setq TeX-parse-self t)
            (setq-default TeX-master nil)
      :mode (("\\.tex$" . LaTeX-mode)))
#+END_SRC

* Programming Languages
** Shell scripting

Make shell scripts executable on save.

#+BEGIN_SRC elisp
  (add-hook 'after-save-hook
            'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

=.zsh= files are shell scripts too.

#+BEGIN_SRC elisp
  (add-to-list 'auto-mode-alist '("\\.zsh\\'" . shell-script-mode))
#+END_SRC

** Python

My bread and butter. Let's make Emacs awesome for Python development.

First, we need to install the =jedi= and =flake8= libraries.
On Mac OS X, Homebrew does a good job with =site-packages=, so we can

#+BEGIN_EXAMPLE
  pip install jedi flake8
#+END_EXAMPLE

On Debian, we leave things not in virtual environments up to the
package manager, so we should do

#+BEGIN_EXAMPLE
  sudo apt-get install python-jedi python-flake8
#+END_EXAMPLE

Now, we'll set up the Emacs part of this.

Have =flake8= run automatically with Flycheck.

#+BEGIN_SRC elisp
  (use-package python-mode
      :init (add-hook 'python-mode-hook 'flycheck-mode))
#+END_SRC

#+BEGIN_SRC elisp
  (use-package jedi
      :commands jedi:setup
      :init
      (add-hook 'python-mode-hook 'jedi:setup)
      (setq jedi:complete-on-dot t))
#+END_SRC

The IPython notebook is quite useful, but so is Emacs.
Obviously we can just do all of the notebook stuff in Emacs!

First, we want to manage dependencies with =virtualenv=,
so we'll use the =virtualenvwrapper= clone for Emacs.

#+BEGIN_SRC elisp
  (use-package virtualenvwrapper
      :init (setq venv-location "~/.virtualenvs")
      :config (venv-initialize-interactive-shells))
#+END_SRC

Now we'll install =ein= to actually edit notebooks in Emacs.

Actually not right now. There are issues.

#+BEGIN_SRC elisp :tangle no
  (use-package ein
      :commands (ein:notebooklist-open ein:jedi-setup)
      :init (add-hook 'ein:connect-mode-hook 'ein:jedi-setup))
#+END_SRC
** Matlab
Gross. But we look at it every now and then.

#+BEGIN_SRC elisp
 (use-package octave-mode
     :ensure f
      :mode ("\\.m$" . octave-mode))
#+END_SRC

** JavaScript

See [[file:emacs-javascript.org][emacs-javascript.el]] for details on working with JavaScript.

#+BEGIN_SRC elisp :tangle no
;;  (load-library "init-javascript")
#+END_SRC

** YAML

#+BEGIN_SRC elisp
  (use-package yaml-mode
      :mode (("\\.yml$" . yaml-mode) ("\\.yaml$" . yaml-mode)))
#+END_SRC

** HTML, CSS and other Web Programming

See [[file:emacs-web.org][emacs-web.el]] for details on working with HTML and its ilk.

#+BEGIN_SRC elisp :tangle no
  (load-library "init-web")
#+END_SRC

** Other

Here's the list Prelude gives.

#+BEGIN_EXAMPLE
(defvar prelude-auto-install-alist
  '(("\\.clj\\'" clojure-mode clojure-mode)
    ("\\.coffee\\'" coffee-mode coffee-mode)
    ("\\.css\\'" css-mode css-mode)
    ("\\.csv\\'" csv-mode csv-mode)
    ("\\.d\\'" d-mode d-mode)
    ("\\.dart\\'" dart-mode dart-mode)
    ("\\.ex\\'" elixir-mode elixir-mode)
    ("\\.exs\\'" elixir-mode elixir-mode)
    ("\\.elixir\\'" elixir-mode elixir-mode)
    ("\\.erl\\'" erlang erlang-mode)
    ("\\.feature\\'" feature-mode feature-mode)
    ("\\.go\\'" go-mode go-mode)
    ("\\.groovy\\'" groovy-mode groovy-mode)
    ("\\.haml\\'" haml-mode haml-mode)
    ("\\.hs\\'" haskell-mode haskell-mode)
    ("\\.kv\\'" kivy-mode kivy-mode)
    ("\\.latex\\'" auctex LaTeX-mode)
    ("\\.less\\'" less-css-mode less-css-mode)
    ("\\.lua\\'" lua-mode lua-mode)
    ("\\.markdown\\'" markdown-mode markdown-mode)
    ("\\.md\\'" markdown-mode markdown-mode)
    ("\\.ml\\'" tuareg tuareg-mode)
    ("\\.pp\\'" puppet-mode puppet-mode)
    ("\\.php\\'" php-mode php-mode)
    ("PKGBUILD\\'" pkgbuild-mode pkgbuild-mode)
    ("\\.rs\\'" rust-mode rust-mode)
    ("\\.sass\\'" sass-mode sass-mode)
    ("\\.scala\\'" scala-mode2 scala-mode)
    ("\\.scss\\'" scss-mode scss-mode)
    ("\\.slim\\'" slim-mode slim-mode)
    ("\\.swift\\'" swift-mode swift-mode)
    ("\\.tex\\'" auctex LaTeX-mode)
    ("\\.textile\\'" textile-mode textile-mode)
    ("\\.thrift\\'" thrift thrift-mode)
    ("\\.yml\\'" yaml-mode yaml-mode)
    ("\\.yaml\\'" yaml-mode yaml-mode)
    ("Dockerfile\\'" dockerfile-mode dockerfile-mode)))
#+END_EXAMPLE

* Backmatter

Just like at the front, we have to put some stuff at the end
to conform to =elisp= standards.

#+BEGIN_SRC elisp
  (provide 'init)
  ;;; init ends here
#+END_SRC


#+DESCRIPTION: A literate programming version of my Emacs Initialization script, loaded by the .emacs file.
#+PROPERTY:    results silent
#+PROPERTY:    tangle ~/.emacs.d/init.el
#+PROPERTY:    eval no-export
#+PROPERTY:    comments org
#+OPTIONS:     num:nil toc:nil todo:nil tasks:nil tags:nil
#+OPTIONS:     skip:nil author:nil email:nil creator:nil timestamp:nil
#+INFOJS_OPT:  view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
